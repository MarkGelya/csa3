# Геля Марк P3232

Вариант: `alg -> asm | acc | neum | hw | instr | binary -> struct | stream | port | pstr | prob2 | cache`

Упрощенный вариант

## Язык программирования

Описание синтаксиса языка в форме БНФ:

```bnf
<program> ::= <line>* <EOF>

<line> ::= <label>? <instruction>? <EOL>

<label> ::= <name> ":"

<name> ::= <NAME>

<instruction> ::= <op> <operand>*

<op> ::= <op0> | <op1> | <op2> | <op3>

<op0> ::= "HLT"

<op1> ::= "WORD" | "SHORT" | "BYTE" | "BYTES"

<op2> ::= "LD" | "ST" | "ADD" | "SUB" | "INC" | "DEC" | "OR" | "AND" | "XOR" | "CMP" | "JMP" | "JE" | "JZ" | "JNE" | "JNZ" | "JG" | "JGE" | "JL" | "JLE" | "JEOF"

<op3> ::= "IN" | "OUT"

<operand> ::= <integer> | <name> | <final_addr> | <final_addr_label> | <bit_depth> | <string>

<final_addr> ::= "*" <integer>

<final_addr_label> ::= "*" <name>

<bit_depth> ::= "b8" | "b16" | "b24" | "b32"

<integer> ::= <DEC_INTEGER> | <HEX_INTEGER> | <OCT_INTEGER> | <BIN_INTEGER>

<string> ::= <StringVar>

<EOF> ::= [end of file]

<EOL> ::= [\r\n]+

<NAME> ::= [a-zA-Z][a-zA-Z0-9]*

<DEC_INTEGER> ::= [0-9]+

<OCT_INTEGER> ::= '0' [qo][0-7]+

<HEX_INTEGER> ::= '0' [xh][0-9A-F]+

<BIN_INTEGER> ::= '0' [b][01]+

<StringVar> ::= '"' (~["\\\r\n] | <ESCAPED_CHAR>)+ '"'

<ESCAPED_CHAR> ::= '\\' ('n' | 'r' | 't' | '"' | '\\')

```

Пример программы:

```asm
        JMP     start
hello:  BYTES   "Hello, world!"
ptr0:   SHORT   hello
ptr:    SHORT   hello
i:      SHORT   0
start:
loop:
        LD      *ptr    b8
        OUT     0
        LD      ptr     b16
        INC
        ST      ptr     b16
        LD      i       b16
        CMP     *ptr0   b8
        JG      end
        INC
        ST      i       b16
        JMP     loop
end:
        HLT

```

Язык поддерживает 4 типа данных:
```
1. WORD - 32bit
2. SHORT - 16bit
3. BYTE - 8 bit
4. BYTES <N> - N bytes
4. BYTES "<text>" - len(<text>)
```

Результат всех математических операций будет "обрезан" до младших 33-бит, 33-ий бит попадёт в carry флаг.


## Организация памяти

Процессор поддерживает два типа адресации:
1. Прямая адресация `LD label`
2. Косвенная адресация `LD *label`

Система построена по архитектуре фон Неймана, то есть разделения команд и данных нет:.

Память работает в линейном, плоском адресном пространстве.

### Регистры

Система обладает аккумуляторной архитектурой. Поэтому большинство операций происходит над аккумулятором. Остальные регистры устанавливаются процессором.

Никакие переменные не отображаются на регистры, так как по сути нам доступен всего один регистр -- аккумулятор.

1. `AC` (accumulator) -- 32-битный регистр общего назначения, используемый для хранения операнда или результата арифметических и логических операций.
2. `DR` (data register) -- 32-битный регистр общего назначения, используемый для хранения второго операнда и для загрузки значения а `AC`.
3. `CR` (command register) -- 8-битный регистр, хранящий код текущей выполняемой команды. Содержит информацию о коде операции и режиме адресации.
4. `IP` (instruction pointer) -- 16-битный регистр, указывающий на адрес следующей команды, которая будет выбрана из памяти. Увеличивается на единицу после извлечения каждого байта.
5. `FAR` (final address register) -- 16-битный регистр, используемый для хранения конечного адреса операнда (косвенная адресация)
6. `BR` (buffer register) -- используется для загрузки операндов из памяти и устройств, команд, конечного адреса и выгрузки данных в память и внешние устройства.
7. 4 8-битных регистра очереди инструкций. (первый в очереди -- инструкция, первый и второй -- адрес)

### Флаги

1. `N` (negative) -- Устанавливается в 1, если результат операции арифметического вычитания или логического сравнения отрицателен.
2. `Z` (zero) -- Устанавливается в 1, если результат операции равен нулю.
3. `C` (carry) -- Устанавливается в 1, если произошел перенос из старшего бита во время операции сложения или вычитания.
4. `V` (overflow) -- Устанавливается в 1, если произошел переполнением во время операции сложения или вычитания со знаком.
5. `E` (End of file) -- Устанавливается внешним устройством для индикации завершения потока, сбрасывается при `JEOF` (Jump if end of file)
6. `O`, `R`, `M` (operand, read, memory) -- Служебные флаги для работы BIU


### Память

Размер машинного слова -- 32 бит.

```
 ╔═════════════════╗
 ║First instruction║  /* JMP start */
 ╚═════════════════╝
 ╔═════════════════╗
 ║                 ║
 ║                 ║
 ║                 ║
 ║                 ║
 ║   Instruction   ║
 ║       and       ║
 ║   data memory   ║
 ║                 ║
 ║                 ║
 ║                 ║
 ║                 ║
 ╚═════════════════╝
```

## Система команд

### Особенности процессора
Прерывания отсутствуют.

Флаг `E` (EOF) используется для индикации конца потока.

Для обращения к внешнему устройству выставить `wire_mem=False`, `wire_read=False/True`, `wire_data_enable=True`, `bus_data` (для записи), `bus_addr` для выбора устройства (`IN 0x0005` -- запись в устройство номер 5)

### Набор инструкций

Инструкции завершения программы:

- `HLT` (остановка) -- 8-bit. Останавливает выполнение программы.

Инструкции манипуляции данными:

- `LD` (загрузить) -- 24-bit. Загружает значение из памяти в аккумулятор.
- `ST` (сохранить) -- 24-bit. Сохраняет значение из аккумулятора в память.
- `ADD` (сложить) -- 24-bit. Складывает значение из аккумулятора и операнда и сохраняет результат в аккумуляторе.
- `SUB` (вычесть) -- 24-bit. Вычитает значение операнда из значения в аккумуляторе и сохраняет результат в аккумуляторе.
- `INC` (инкремент) -- 8-bit. Инкрементирует значение в памяти или аккумуляторе.
- `DEC` (декремент) -- 8-bit. Декрементирует значение в памяти или аккумуляторе.
- `OR` (логическое ИЛИ) -- 24-bit.  Выполняет операцию логического ИЛИ между аккумулятором и операндом и сохраняет результат в аккумуляторе.
- `AND` (логическое И) -- 24-bit.  Выполняет операцию логического И между аккумулятором и операндом и сохраняет результат в аккумуляторе.
- `XOR` (логическое исключающее ИЛИ) -- 24-bit.  Выполняет операцию логического исключающего ИЛИ между аккумулятором и операндом и сохраняет результат в аккумуляторе.
- `CMP` (сравнить) -- 24-bit. Сравнивает значения в аккумуляторе и операнде и устанавливает флаги условий.

Инструкции ветвления:

- `JMP` (перейти) -- 24-bit.  Переходит на адрес, указанный операндом.
- `JE` (перейти при равенстве) -- 24-bit. Переходит на адрес, указанный операндом, если значение в аккумуляторе равно нулю.
- `JZ` (перейти при нуле) -- 24-bit.  Переходит на адрес, указанный операндом, если значение в аккумуляторе равно нулю.
- `JNE` (перейти при неравенстве) -- 24-bit.  Переходит на адрес, указанный операндом, если значение в аккумуляторе не равно нулю.
- `JNZ` (перейти при не ноль) -- 24-bit.  Переходит на адрес, указанный операндом, если значение в аккумуляторе не равно нулю.
- `JG` (перейти при больше) -- 24-bit.  Переходит на адрес, указанный операндом, если значение в аккумуляторе больше нуля.
- `JGE` (перейти при больше или равно) -- 24-bit.  Переходит на адрес, указанный операндом, если значение в аккумуляторе больше или равно нулю.
- `JL` (перейти при меньше) -- 24-bit. Переходит на адрес, указанный операндом, если значение в аккумуляторе меньше нуля.
- `JLE` (перейти при меньше или равно) -- 24-bit. Переходит на адрес, указанный операндом, если значение в аккумуляторе меньше или равно нулю.
- `JEOF` (перейти при конце файла) -- 24-bit. Переходит на адрес, указанный операндом, если достигнут конец файла ввода. После выполнения флаг EOF будет сброшен.

Инструкции ввода-вывода:

- `IN` (ввод) -- 24-bit. Считывает байт из последовательного устройства и сохраняет его в аккумуляторе.
- `OUT` (вывод) -- 24-bit. Выводит байт из аккумулятора в последовательное устройство.

### Способ кодирования инструкций

- 5-bit: код операции (opcode)
- 2-bit: 8/16/24/32 битный операнд
- 1-bit: прямая/косвенная адресация
- 16-bit: адрес

В зависимости от opcode оставшиеся 3 бита могут быть интерпретированы как расширение opcode. Пример: `HLT`, `INC`, `DEC`

## Транслятор

`python compiler.py <input_file> <output_file>`

## Модель процессора

`python machine.py <input_code_file> <input_data_file>`

### CPU

![](doc/cpu.png)
* `V`, `GND`: Питание
* `A0`-`A15`: 16-разрядная шина адреса
* `D0`-`D7`: 8-разрядная шина адреса
* `RD/WR`: Сигнал чтения/записи, `1` -- чтение `0` -- запись
* `MEM/IO`: Сигнал выбора, `1` -- память `0` -- устройство
* `ENABLE`: Сигнал активации, сообщающий внешним устройствам, что данные и адрес выставлены на шину.
* `READY`: Сигнал готовности, сообщающий процессору, что данные выставлены на шину или были прочитаны.
* `EOF`: Сигнал окончания передачи.
* `INSTR`: Сигнал завершения инструкции, сигнализирующий о завершении выполнения текущей инструкции.
* `HLT`: Сигнал остановки (инструкция `HLT`).
* `CLK`: Сигнал тактовой частоты, управляющий работой процессора. 

### Machine

![](doc/bcomp.png)

* `RUN`: Используется для запуска тактового генератора.
* `HLT`: Останавливает тактовый генератор.

* `CLOCK GENERATOR`: Генерирует cигнал тактовой частоты для процессора.
* `Selector`: Выборка устройства. Пример:
  * `if MEM/IO == 1 then RAM`
  * `if MEM/IO == 0 and ADDR == 0x0 then Device1`
* `Transceivers`: Подключает устройство к шинам.

### DataPath

![](doc/cpu_dp.png)

* `AC` -- Accumulator
* `DR` -- Data Register
* `CR` -- Command Register
* `IP` -- Instruction Pointer
* `FAR` -- Final Address Register
* `BR` -- Buffer Register


* `NZCV` -- Negative, Zero, Carry, oVerflow
* `E` -- End of file
* `O` -- Operand fetch
* `R` -- Read
* `M` -- Memory


* `Instruction queue`: Работает как обычная очередь:
  * `skip` = `pop()`
  * `skip_addr` = `pop(); pop()`
  * `instr_fetch` = `push(data1)`
  * `instr`: первый байт
  * `addr`: первый и второй байт

Изначально `CU` находится в состояние `InstructionFetch`, так как `Instruction queue` пуст, то `CU` будет ожидать сигнала `instr_ready`. В это время `BIU` (Bus Interface Unit) извлекает инструкции из памяти (`O` = `False`, `R` = `True`, `M` = `True`, `IP` = `0x0000`) и отправляет их в `Instruction queue`. Когда инструкция попадёт в `Instruction queue`, то `CU` извлечёт инстукцию и выставит `skip`, если инструкция адресная, то будет ожидать адрес (`addr_ready`).

`BIU` может выполнять несколько задач в зависимости от команд `CU`:
* InstructionFetch (default)
* OperandFetch: `operand` и `direct`
* AddressFetch: `operand` и `indirect`

### ControlUnit

![](doc/cpu_cu.png)

* `CR` -- Command Register
* `TC` -- Tick Counter
* `Bd` -- Bit depth {0: 8, 1: 16, 2: 24, 3: 32}

Выборка комбинационной схемы происходит следующим образом:
* Строка -- Command Counter
* Столбец -- Tick Counter

`TC` привязан к `CLK`, но может блокироваться (к примеру ожидание инструкции). Так

`Bd` используется как счетчик для выбора от 1 до 4 байт.

## Тестирование

Тестирование выполняется при помощи golden test-ов.

Тестовое покрытие:
- `hello` - вывод `Hello, world!`
- `hello_user_name` - ввод строки (PascalString) и вывод `Hello, <username>!`
- `cat` - потоки ввода-вывода
- `prob2` - вычисляет сумму всех четных чисел Фибоначчи до 4 000 000

Пример запуска тестов:
```
poetry run pytest . -v
======================================================================================== test session starts =========================================================================================
platform linux -- Python 3.12.3, pytest-7.4.4, pluggy-1.5.0 -- /home/user/.cache/pypoetry/virtualenvs/csa-choEqhad-py3.12/bin/python
cachedir: .pytest_cache
rootdir: /home/user/project
configfile: pyproject.toml
plugins: golden-0.2.2
collected 4 items                                                                                                                                                                                    

golden_test.py::test_translator_and_machine[golden/prob2.yml] PASSED                                                                                                                           [ 25%]
golden_test.py::test_translator_and_machine[golden/cat.yml] PASSED                                                                                                                             [ 50%]
golden_test.py::test_translator_and_machine[golden/hello_user_name.yml] PASSED                                                                                                                 [ 75%]
golden_test.py::test_translator_and_machine[golden/hello.yml] PASSED                                                                                                                           [100%]

========================================================================================= 4 passed in 12.83s =========================================================================================
```

## Статистика

```
| ФИО                 | алг             | LoC | code байт | code инстр. | инстр. | такт.  | вариант                                                                                        |
| Геля Марк Романович | hello           | 13  | 53        | 13          | 152    | 2983   | alg -> asm | acc | neum | hw | instr | binary -> struct | stream | port | pstr | prob2 | cache |
| Геля Марк Романович | hello_user_name | 60  | 459       | 60          | 422    | 8061   | alg -> asm | acc | neum | hw | instr | binary -> struct | stream | port | pstr | prob2 | cache |
| Геля Марк Романович | cat             | 6   | 16        | 6           | 855    | 18178  | alg -> asm | acc | neum | hw | instr | binary -> struct | stream | port | pstr | prob2 | cache |
| Геля Марк Романович | prob2           | 25  | 97        | 25          | 414    | 11889  | alg -> asm | acc | neum | hw | instr | binary -> struct | stream | port | pstr | prob2 | cache |
```
